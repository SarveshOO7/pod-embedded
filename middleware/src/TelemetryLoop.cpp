/* 
 * Please note that this is an auto-generated file which is automatically generated whenever a target is built.
 */

#include "TelemetryLoop.h"

#include <iostream>
#include <unistd.h>
#include <cstdio>
#include <pthread.h>
#include <stdint.h>
#include <memory.h>
#include <vector>
#include <bitset>
#include <PracticalSocket/PracticalSocket.h>
#include "data.h"
#include <CRCpp/CRC.h>
#include <chrono>

extern "C" {
#include <hv_iox.h>
#include <lv_iox.h>
}


#define BUFFER_SIZE 500
#define ENDIAN "LITTLE" // TODO: Is there a way to check this during compile-time or something?

// Because it kind of looks like "BADGER"
#define HEADER 0xBAD6E4



pthread_t telemetryThread;

template <typename type>
void addToBuffer(std::vector<uint8_t>* buffer, type* value, uint8_t size = 0){
    // TODO: Find some way to send information about the CPU-dependent sizes to standardize things

    // If not explicitly stated, the number of bits is the size of the contents of the pointer
    int bytes = (size == 0) ? sizeof(*value) : size;

    const uint8_t* byteArray = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(value));

    for(int i = 0; i < bytes; i++)
        if(ENDIAN == "BIG") // NOLINT(misc-redundant-expression)
            buffer->push_back(byteArray[(bytes - 1) - i]);
        else
            buffer->push_back(byteArray[i]);
}

void SetupTelemetry(char* ip, int port){
    TelemArgs *args = (TelemArgs*) malloc(sizeof(TelemArgs));

    // Ensure memory was actually allocated
    if(args == NULL){
        fprintf(stderr, "MALLOC ERROR\n");
        exit(1);
    }

    // Assign the telemetry arguments
    args -> ipaddr = strdup(ip);
    args -> port = port;

    // Create a thread for the telemetry loop to run in
    if (pthread_create(&telemetryThread, NULL, TelemetryLoop, args))
        fprintf(stderr, "Error creating LV Telemetry thread\n");
}

void* TelemetryLoop(void *arg) {
    // Cast the argument
    TelemArgs *sarg = (TelemArgs *) arg;

    try {
        // Create a UDP socket which telemetry packets are rapidly sent to
        UDPSocket sock;

        // Sent with each packet to keep track of ordering
        uint32_t packetNumber = 0;

        // Buffer to be sent by the socket
        std::vector<uint8_t> buffer;
        buffer.reserve(BUFFER_SIZE); // Prevents constant reallocation which can slow things down

        const uint32_t header = HEADER;

        while (true) {
            // Header: Write BAD6E4 (Because it kind of looks like "Badger")
            addToBuffer(&buffer, &header, 3);

            // Contents: Loop through the data and add everything in

            // Write 4 byte packet count
            addToBuffer(&buffer, &packetNumber);

            // Write 8 byte time
            uint64_t time = chrono::duration_cast<chrono::milliseconds>(
                    std::chrono::system_clock::now().time_since_epoch()
            ).count();
            addToBuffer(&buffer, &time);

            // Write 1 byte IMD status
            uint8_t imdStatus = getIMDStatus();
            addToBuffer(&buffer, &imdStatus);

            // Write 4 byte primary brake
            int32_t primBrake = 0;
            #ifndef TELEMETRY_LOOP_TEST
                primBrake = limSwitchGet(PRIM_LIM_SWITCH);
            #endif
            addToBuffer(&buffer, &primBrake);

            // Write 4 byte secondary brake
            int32_t secBrake = 0;
            #ifndef TELEMETRY_LOOP_TEST
                secBrake = limSwitchGet(SEC_LIM_SWITCH);
            #endif
            addToBuffer(&buffer, &secBrake);

            
            /* Autogenerated Code Begins */
            addToBuffer(&buffer, &data->state);
            addToBuffer(&buffer, &data->pressure->primTank);
            addToBuffer(&buffer, &data->pressure->primLine);
            addToBuffer(&buffer, &data->pressure->primAct);
            addToBuffer(&buffer, &data->pressure->secTank);
            addToBuffer(&buffer, &data->pressure->secLine);
            addToBuffer(&buffer, &data->pressure->secAct);
            addToBuffer(&buffer, &data->pressure->amb);
            addToBuffer(&buffer, &data->pressure->pv);
            addToBuffer(&buffer, &data->motion->pos);
            addToBuffer(&buffer, &data->motion->vel);
            addToBuffer(&buffer, &data->motion->accel);
            addToBuffer(&buffer, &data->motion->retroCount);
            addToBuffer(&buffer, &data->motion->missedRetro);
            addToBuffer(&buffer, &data->bms->packCurrent);
            addToBuffer(&buffer, &data->bms->packVoltage);
            addToBuffer(&buffer, &data->bms->imdStatus);
            addToBuffer(&buffer, &data->bms->packDCL);
            addToBuffer(&buffer, &data->bms->packCCL);
            addToBuffer(&buffer, &data->bms->packResistance);
            addToBuffer(&buffer, &data->bms->packHealth);
            addToBuffer(&buffer, &data->bms->packOpenVoltage);
            addToBuffer(&buffer, &data->bms->packCycles);
            addToBuffer(&buffer, &data->bms->packAh);
            addToBuffer(&buffer, &data->bms->inputVoltage);
            addToBuffer(&buffer, &data->bms->Soc);
            addToBuffer(&buffer, &data->bms->relayStatus);
            addToBuffer(&buffer, &data->bms->highTemp);
            addToBuffer(&buffer, &data->bms->lowTemp);
            addToBuffer(&buffer, &data->bms->avgTemp);
            addToBuffer(&buffer, &data->bms->cellMaxVoltage);
            addToBuffer(&buffer, &data->bms->cellMinVoltage);
            addToBuffer(&buffer, &data->bms->cellAvgVoltage);
            addToBuffer(&buffer, &data->bms->maxCells);
            addToBuffer(&buffer, &data->bms->numCells);
            addToBuffer(&buffer, &data->rms->igbtTemp);
            addToBuffer(&buffer, &data->rms->gateDriverBoardTemp);
            addToBuffer(&buffer, &data->rms->controlBoardTemp);
            addToBuffer(&buffer, &data->rms->motorTemp);
            addToBuffer(&buffer, &data->rms->motorSpeed);
            addToBuffer(&buffer, &data->rms->phaseACurrent);
            addToBuffer(&buffer, &data->rms->phaseBCurrent);
            addToBuffer(&buffer, &data->rms->phaseCCurrent);
            addToBuffer(&buffer, &data->rms->dcBusVoltage);
            addToBuffer(&buffer, &data->rms->lvVoltage);
            addToBuffer(&buffer, &data->rms->canCode1);
            addToBuffer(&buffer, &data->rms->canCode2);
            addToBuffer(&buffer, &data->rms->faultCode1);
            addToBuffer(&buffer, &data->rms->faultCode2);
            addToBuffer(&buffer, &data->rms->commandedTorque);
            addToBuffer(&buffer, &data->rms->actualTorque);
            addToBuffer(&buffer, &data->rms->relayState);
            addToBuffer(&buffer, &data->rms->electricalFreq);
            addToBuffer(&buffer, &data->rms->dcBusCurrent);
            addToBuffer(&buffer, &data->rms->outputVoltageLn);
            addToBuffer(&buffer, &data->rms->VSMCode);
            addToBuffer(&buffer, &data->rms->keyMode);
            addToBuffer(&buffer, &data->flags->readyPump);
            addToBuffer(&buffer, &data->flags->pumpDown);
            addToBuffer(&buffer, &data->flags->readyCommand);
            addToBuffer(&buffer, &data->flags->readyToBrake);
            addToBuffer(&buffer, &data->flags->propulse);
            addToBuffer(&buffer, &data->flags->emergencyBrake);
            addToBuffer(&buffer, &data->flags->shouldStop);
            addToBuffer(&buffer, &data->flags->shutdown);
            addToBuffer(&buffer, &data->flags->shouldBrake);
            addToBuffer(&buffer, &data->flags->isConnected);
            addToBuffer(&buffer, &data->flags->brakeInit);
            addToBuffer(&buffer, &data->flags->brakePrimAct);
            addToBuffer(&buffer, &data->flags->brakeSecAct);
            addToBuffer(&buffer, &data->flags->brakePrimRetr);
            addToBuffer(&buffer, &data->flags->brakeSecRetr);
            addToBuffer(&buffer, &data->flags->clrMotionData);
            addToBuffer(&buffer, &data->timers->startTime);
            addToBuffer(&buffer, &data->timers->oldRetro);
            addToBuffer(&buffer, &data->timers->lastRetro);
            addToBuffer(&buffer, &data->timers->lastRetros);
            addToBuffer(&buffer, &data->timers->crawlTimer);
            /* Autogenerated Code Ends */
            

            // Tail: Cyclic Redundancy Check (32 bit)
            uint32_t crc = CRC::Calculate(buffer.data(), buffer.size(), CRC::CRC_32());
            addToBuffer(&buffer, &crc);

            // Send data and reset buffer
            sock.sendTo(buffer.data(), buffer.size(), sarg->ipaddr, sarg->port);
            buffer.clear();

            packetNumber ++;

            #ifdef TELEMETRY_LOOP_TEST
                if(packetNumber % 100 == 0){
                    cout << packetNumber << " packets have been sent.\n";
                    cout.flush();
                }
            #endif

            // Pause for 30 milliseconds before sending the next packet
            usleep(30000);
        }
    } catch (SocketException &e) {
        cerr << e.what() << endl;
        exit(1);
    }
}