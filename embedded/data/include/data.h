/* 
 * Please note that this is an auto-generated file which is automatically generated whenever CMake runs.
 */

#ifndef __DATA_H__
#define __DATA_H__

#include <stdint.h>
#include <time.h>
#include <retro.h>
#include <stdbool.h>
#define TIME_SINCE_LAST_RETRO 15000000
#define FILTER_NONE     0
#define FILTER_ROLLING  1
#define FILTER_EXP      2

/* Filters */
float rollingAvgFloat(float *vals, int windowSize);
int rollingAvgInt(int *vals, int windowSize);
float expFilterFloat(float currVal, float prevVal, float weight);
int expFilterInt(int currVal, int prevVal, float weight);

int initMetaData(void);
int isEarlyInit(void);


/* Autogenerated Code Begins */
int initData(void);
int initPressureData(void);
int initMotionData(void);
int initBmsData(void);
int initRmsData(void);
int initFlagData(void);
int initTimerData(void);

// Top of the great hierarchy of our descending data tree.
typedef struct data_t {
	int state;
	// Pressure information from the braking system
	struct pressure_t *pressure;
	// Where all motion data goes. X-positive direction is assumed. All values should be assumed to be metr
	// ic.
	struct motion_t *motion;
	// Data collected about the battery system
	struct bms_t *bms;
	// Collection of all the RMS (motor controller) data
	struct rms_t *rms;
	// Where information about the flags is held.
	struct flags_t *flags;
	// For making sure that our run happens in a timely manner
	struct timers_t *timers;
} data_t;

// Pressure information from the braking system
typedef struct pressure_t {
	double primTank;
	double primLine;
	double primAct;
	double secTank;
	double secLine;
	double secAct;
	double amb;
	double pv;
} pressure_t;

// Where all motion data goes. X-positive direction is assumed. All values should be assumed to be metr
// ic.
typedef struct motion_t {
	float pos;
	float vel;
	float accel;
	int retroCount;
	int missedRetro;
} motion_t;

// Data collected about the battery system
typedef struct bms_t {
	float packCurrent;
	float packVoltage;
	int imdStatus;
	uint16_t packDCL;
	int16_t packCCL;
	uint16_t packResistance;
	uint8_t packHealth;
	float packOpenVoltage;
	uint16_t packCycles;
	uint16_t packAh;
	float inputVoltage;
	uint8_t Soc;
	uint16_t relayStatus;
	uint8_t highTemp;
	uint8_t lowTemp;
	uint8_t avgTemp;
	float cellMaxVoltage;
	float cellMinVoltage;
	uint16_t cellAvgVoltage;
	uint8_t maxCells;
	uint8_t numCells;
} bms_t;

// Collection of all the RMS (motor controller) data
typedef struct rms_t {
	uint16_t igbtTemp;
	uint16_t gateDriverBoardTemp;
	uint16_t controlBoardTemp;
	uint16_t motorTemp;
	int16_t motorSpeed;
	int16_t phaseACurrent;
	uint16_t phaseBCurrent;
	uint16_t phaseCCurrent;
	int16_t dcBusVoltage;
	uint16_t lvVoltage;
	uint64_t canCode1;
	uint64_t canCode2;
	uint64_t faultCode1;
	uint64_t faultCode2;
	int16_t commandedTorque;
	int16_t actualTorque;
	uint16_t relayState;
	uint16_t electricalFreq;
	int16_t dcBusCurrent;
	uint16_t outputVoltageLn;
	uint16_t VSMCode;
	uint16_t keyMode;
} rms_t;

// Where information about the flags is held.
typedef struct flags_t {
	int readyPump;
	int pumpDown;
	int readyCommand;
	bool readyToBrake;
	int propulse;
	int emergencyBrake;
	int shouldStop;
	int shutdown;
	bool shouldBrake;
	bool isConnected;
	bool brakeInit;
	bool brakePrimAct;
	bool brakeSecAct;
	bool brakePrimRetr;
	bool brakeSecRetr;
	bool clrMotionData;
} flags_t;

// For making sure that our run happens in a timely manner
typedef struct timers_t {
	uint64_t startTime;
	uint64_t oldRetro;
	uint64_t lastRetro;
	uint64_t lastRetros[NUM_RETROS];
	uint64_t crawlTimer;
} timers_t;
/* Autogenerated Code Ends */


static inline uint64_t convertTouS(struct timespec *currTime) {
    return (uint64_t)((currTime->tv_sec * 1000000) + (currTime->tv_nsec / 1000));
}

static inline uint64_t getuSTimestamp() {
    struct timespec _temp;
    clock_gettime(CLOCK_MONOTONIC, &_temp);
    uint64_t _tempTs = convertTouS(&_temp);
    return _tempTs;
}

static inline uint64_t getSTimestamp() {
    struct timespec temp;
    clock_gettime(CLOCK_MONOTONIC, &temp);
    return (uint64_t) (temp.tv_sec);
}

extern data_t *data;
#endif